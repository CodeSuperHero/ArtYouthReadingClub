<!-- TOC -->

- [2.1.1 逆映射 [Inverse Mappings]](#211-%E9%80%86%E6%98%A0%E5%B0%84-inverse-mappings)
- [2.1.2 区间 [Intervals]](#212-%E5%8C%BA%E9%97%B4-intervals)
- [2.1.3 对数 [Logarithms]](#213-%E5%AF%B9%E6%95%B0-logarithms)

<!-- /TOC -->

&emsp;&emsp;映射，也被称为函数，是数学和程序的基础。和函数在程序中类似，映射在数
学中也是接收一种"类型"的输入参数，然后返回特定类型的对象。在程序中我们成为"类型"，
在数学中我们称之为集合。当我们一个集合理的成员对象，我们使用 $\epsilon$ 符号表示。
例如:
 
$$ a \epsilon S $$
 
可以被读为 $a$ 是 $S$ 一个成员。给定两个集合 $A$ 和 $B$，我们可以通过”笛卡
尔乘积“操作得到第三个集合，表示为 $A$ x $B$。这个集合由所有可能的有序二元组
_(a, b)_ 组成，其中 $a \epsilon A$ 和 $b \epsilon B$ 。我们可以使
用$A^2$来表示 $A$ x $A$ 。我们可以通过拓展笛卡尔乘积，从三个集合得到一个
包含所有可能有序三元组的集合，以及从任意多个集合得到任意长度的元组序列。
 
下面列出一些通用的集合:
- $\mathbb{R}$ : 实数集合
- $\mathbb{R}^+$ : 正实数集合
- $\mathbb{R}^2$ : 实数2d平面的有序元组集合
- $\mathbb{R}^n$ : n维笛卡尔空间中的点集合
- $\mathbb{Z}$ : 整数集合
- $\mathbb{S}^2$ : 在单位球面上的3D点集合。

&emsp;&emsp;注意虽然 $\mathbb{S}^2$ 是由3维空间的点组成，但是他们都是处在一个
可以被两个变量参数化表示的表面上，所以他们也可以被认为是一个2D集合。映射符号用箭头
和冒号组成，如下所示:
 $$f = \mathbb{R}\mapsto\mathbb{Z}$$
你可以读成”$f$是把输入的实数参数映射成整数的函数“。这个集合在箭头左边的部分称为函数
的 _域(domain)集合_ ，箭头右边的集合称为 _目标(target)_集合 。计算机程序可以用下面的语言
更加优雅的表达:"函数$f$，输入一个实数，返回一个整数"。换句话说，上面的集合符号相对于
通用的计算机符号语言如下所示:

 integer $f$ (real) $\leftarrow equivalent \rightarrow f : \mathbb{R} \mapsto \mathbb{Z}$

 所以箭头符号可以被程序语言很简单的表达。

 &emsp;&emsp;这个函数 $f(a)$ 被称为a的映像，集合 $A$ _(域集合的子集)_ 的映像是一个包
 含了 $A$ 集合的所有点的映像的目标子集。

###2.1.1 逆映射 [Inverse Mappings]

&emsp;&emsp;如果我们有一个函数 $f : A\mapsto B$,那么就相应存在一个逆函数
$f ^ {-1} : B \mapsto A$,对应的定义规则是$f^{-1}(b) = a$ 或者$b = f(a)$。
这个定义生效有两个条件，第一个条件是$b \epsilon B$ 是函数 $f$ 中的某个点的映像，
第二个条件是只有唯一的一个 $a$ 存在映射$f(a) = b$ 。这样的映射或者函数叫做双射
_(bijections)_。在双射中，对于每一个$a \epsilon A$都有一个唯一的$b \epsilon B$，
同时对于每一个$b \epsilon B$ 都一定存在一个$a \epsilon A$符合映射$f(a) = b$。
双射就类似于一组骑手和一组马的关系，每一个骑手只能对骑着的那一匹马发出指令，而每
一匹马都被骑手骑着。这两个函数就像骑手(马)和马(骑手)。它们都相互存在一个逆函数。函数
如果不是双射，那么就一定没有逆。

&emsp;&emsp;一个双射函数的例子: $f : \mathbb{R} \mapsto \mathbb{R}$ 和 $f ^ {-1}(x) = x ^ 3$。
逆函数是$f ^ {-1} (x) = \sqrt [3] {x}$。这个例子展示了一个标准符号表示法会产生误解因为虚拟
变量$x$被同时用在了 $f$和$f ^ {-1}$。有时候为了更直观，我们往往选择用不同的虚拟变量来表示两个函数
例如: $y = f(x)$和$x = f ^ {-1}()y$。同时我们也能找到没有逆函数的函数，例如当 $sqr(x) = x ^ 2$
开平方函数: $\mathbb{R} \mapsto \mathbb{R}$ 没有逆，因为 $x^2 = (-x)^2$,没有域集合的
成员能够映射到目标集合的负值部分。需要注意的是，当我们限定域集合的范围在 $\mathbb{R}^+$ 我们
就可以定义一个逆函数，$\sqrt x$就是一个有效地逆值。

###2.1.2 区间 [Intervals]

&emsp;&emsp;我们通常都希望处理实数的函数能够限定值范围。指定这类约束的行为我们称作”区间 _[interval]_ “。
一个位于0和1之间，但是不包含0或者1的区间，我们记为(0,1)。因为它没有包含自己的端点，所以这样的集合
我们称作 “开区间 _[open interval]_ “。与之对应包含自己端点的区间则称为”闭区间 _[close interval]_ “，
记为[0,1]。这两个符号可以混用，[0,1)包含了0但是没有包含1。当写下区间[a,b]时，我们默认 $a \le b$。
区间的笛卡尔乘积会经常被使用到。例如:为了表示一个点 $x$ 位于3D空间的单位立方体上，我们可以声明
区间 $x \epsilon [0,1] ^ 3$。

&emsp;&emsp;区间与集合操作的配合使用时非常有用的:交集(_intersection_)，并集(_union_)，和差集(_difference_)。
交集的表示符号是$\cap$，两个区间的交集是他们所共同拥有的点的集合，例如:$[3,5) \cap [4,6] = [4,5)$。
并集的表示符号是$\cup$，两个区间的并集是他们所有的点的集合，例如:$[3,5) \cup [4,6] = [3,6]$。
差集的表示符号是$-$，和前面两个操作不太一样，差集操作的结果依赖于两个区间的前后顺序，总是会返回
位于前面区间而没有位于后面区间的点。例如:$[3,5) - [4,6] = [3,4)$和$[4,6] - [3,5)= [5,6]$。

### 2.1.3 对数 [Logarithms]

&emsp;&emsp;虽然在计算器出现后已经不再流行，但是对数(_logarithms_)在遇到指数方程的问题时非
常有用。通过定义知道，每一个对数都有一个底$a$。底为 $a$ 对数$x$，我们记为 $\log_ax$。
$$y = \log_ax \Longleftrightarrow a^y = x$$
注意对数的底$a$和次幂函数是互相可逆的。这个基础的定义会产生几个重要影响：
- $a^{log_a(x)} = x$；
- $log_a(a^x) = x$；
- $log_a(xy) = log_ax + log_ay$；
- $log_a(x/y) = log_ax - log_ay$；
- $log_ax = log_ab log_bx$。

当我们用于计算对数时，特殊的数字$e = 2.718...$经常会出现。以$e$为底的对数称作自然对数(_natural logarithm_)。
我们采用了通用的简写$ln$用于表示自然对数:
$$lnx \equiv log_ex$$
注意符号"$\equiv$"读做恒等于。就像$\pi$,特殊的数字"$e$"也是一个非常重要的数字。许多领域还会
使用其它特殊的底，用于在符号中操作和省略底数，即$logx = log_10x$，$lbx = log_2x$。例如:天文学家经常省略以10为底的对数底数，
计算机理论科学家经常省略以2为底的对数底数。因为计算机图形学有使用很多其它领域的技术，所以我们会
避免使用简写。

&emsp;&emsp;下面的衍生公式阐明了为什么自然对数会叫做”自然“:
$$\frac {d}{dx} log_ax = \frac 1{xlna}$$
$$\frac {d}{dx} a^x = a^xlna$$ 
能使上面两个公式成立的条件只能是 $a = e$。


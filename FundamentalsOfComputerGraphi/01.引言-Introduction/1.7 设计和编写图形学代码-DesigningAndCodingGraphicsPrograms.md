<!-- TOC -->

- [1.7.1 类设计[Class Design]](#171-%E7%B1%BB%E8%AE%BE%E8%AE%A1class-design)
- [1.7.2 浮点数 vs. 双精度浮点数[float vs double]](#172-%E6%B5%AE%E7%82%B9%E6%95%B0-vs-%E5%8F%8C%E7%B2%BE%E5%BA%A6%E6%B5%AE%E7%82%B9%E6%95%B0float-vs-double)
- [1.7.3 调试图形程序[Debugging Graphics Programs]](#173-%E8%B0%83%E8%AF%95%E5%9B%BE%E5%BD%A2%E7%A8%8B%E5%BA%8Fdebugging-graphics-programs)
    - [科学的方法](#%E7%A7%91%E5%AD%A6%E7%9A%84%E6%96%B9%E6%B3%95)
    - [把图像最为代码调试的输出](#%E6%8A%8A%E5%9B%BE%E5%83%8F%E6%9C%80%E4%B8%BA%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95%E7%9A%84%E8%BE%93%E5%87%BA)
    - [使用调试器](#%E4%BD%BF%E7%94%A8%E8%B0%83%E8%AF%95%E5%99%A8)
    - [数据可视化调试](#%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E8%B0%83%E8%AF%95)

<!-- /TOC -->

&emsp;&emsp;某些常见的策略在图形学编程中通常都很有用。在本节中，我们会提供一些建议，这些建议会在
你学习本书并实现其中的一些方法时产生帮助。

## 1.7.1 类设计[Class Design]

&emsp;&emsp;任何图形程序的关键部分都是拥有用于处理几何实体例如向量和矩阵以及处理图形实体例如RGB
颜色和图像的的良好设计的类和例行程序。这些例行程序要尽可能的简洁和高效。一种通用的问题是坐标和矢量
是否应该是单独的类，因为它们具有不同的操作，把一个坐标乘以0.5没有几何意义,但是矢量乘以0.5却有几何
意义。对这个问题，几乎没有一致的意见，这可以在图形从业者中激发数小时的激烈辩论，但是为了距离，让我
们假设我们不会做出区别。
&emsp;&emsp;这意味着这些基本的类要包括:

- Vector2. 一个2D向量类，存储有一个x分量和一个y分量。它应该把这两个分量存储在长度为2的数组中，
  以便支持索引操作符。您还应该包括矢量加法，减法，点积，叉积，数量乘法和数量除法。
- Vector3. 一个类似2D向量的3D向量类。
- hvector. 具有四个分量的齐次向量。(详情见第七章)
- rgb. 一个rgb颜色存储有三个颜色分量，你还应该包括 rgb的加法，减法，乘法， 数量乘法和数量除法。
- transform. 用于变换的4x4矩阵。应该包括 矩阵乘法和成员函数，以应用于位置，方向和表面法向
  量。如第六章所示，这些都是不同的。
- image. 存储RGB像素的2维数组。

&emsp;&emsp;此外，你也可能需要给区间，标准正交和坐标系添加类。

## 1.7.2 浮点数 vs. 双精度浮点数[float vs double]

&emsp;&emsp;现代架构建议保持低内存使用以及保持连续的内存访问，是提高效率的关键，所以这里建议
使用单精度浮点数，然而，为了避免数值问题依然建议使用双精度运算。如何权衡依赖于程序的实际情况，
但是如果在你的类里面有一个默认精度的定义是非常好的。

## 1.7.3 调试图形程序[Debugging Graphics Programs]

&emsp;&emsp;如果你问问周围，你会发现当越是经验丰富的程序员，会越少使用传统调试器。一个原因是使
用这样的调试器在面对复杂程序时无法发挥作用，另外一个原因是最棘手的错误，往往是那些已经被实现的设
计(conceptual)上的错误，这些错误往往需要花费大量的时间去通过变量值一步一步的查找错误的根源，而
不可能通过分析案例查找到原因。我们总结了几个用于图形学调试特别有用的策略。

### 科学的方法
&emsp;&emsp;在图形程序中有一种替代传统调试的方法非常有用:我们创建一个图像并且去观察这个图像的问
题，然后根据发现的问题，假设导致这些问题出现的原因，然后再去做测试来验证。例如:在光线追踪程序中，
我们可能会遇到很多随机的黑色像素。这是经典的"shadow acne"问题，大多数人在写光线追踪器的时候都会
遇到。传统的调试方法在这个时候没有任何作用，我们必须意识到阴影光线是撞击在表面着色器上，我们可能会
注意到斑点的颜色是环境颜色，所以是直接光照(direct lighting)因为某种原因丢失了，直接光照(direct
lighting)可以在阴影中被关闭，所以你可以假设这些斑点并没有在阴影中但是却被错误的标记到了阴影中，为
了验证这个假设，我们需要关闭阴影检查,再重新编译程序，新的程序运行结果会验证我们的猜测。这种方法有时
候非常有效的关键原因是我们无法发现这个错误的值，也无法准确判断我们在设计(conceptual)上的错误。所以
，我们只能通过实验来缩小错误的范围，通常情况下只需要进行少数几次实验来跟踪错误，毫无疑问，这种调试方
式会比较让人愉快。

### 把图像最为代码调试的输出
&emsp;&emsp;在大多数案例中，从图形程序中获取有效调试信息的最简单方式就是输出图像本身，如果你想查看
为每个像素的运行的计算中的部分变量的值，可以临时修改程序把这部分值直接复制到到输出的图像上并且跳过其
余正常的计算流程。例如:如果你怀疑表面法线导致了着色问题，你可以直接复制法向量到图像上(x to r,y to 
g, z to b),从而生成实际用于计算的法向量图像。或者，如果你怀疑某个具体的值有时候会超出其有效范围，
可以让程序在这种情况发生时写入一个高亮的红色像素。其他常见的技巧包括用明显不同的颜色绘制背面(当他们
不应该是可见的)，根据对象的ID号来绘制图像，或者根据计算他们所花费的时间来绘制图像。

### 使用调试器
&emsp;&emsp;仍然有一些案例，特别是当采用科学的方法会产生一些矛盾的地方，也没有好的方法可以准确观察
到程序当前的运行状态。麻烦的事情是图形程序通常涉及许多相同代码的执行(比如每个像素一次，或每个三角形
一次)，这使得通过调试器从开始逐步调试是不可能做到的。而且最难的错误通常只发生在有复杂输入的时候。
&emsp;&emsp;一个有用的方法是给错误“设置陷阱”。首先，保证程序的输出是确定的-运行在单线程下并且确保
所有的随机数计算都使用的固定的种子。然后，找出显示错误的那个像素或者三角形，并在怀疑的错误代码前添加
一些语句，该代码只对可疑案例执行。例如，如果发现像素(126,247)显示错误，请添加: 
```
if x = 126 and y = 247 then
  print "blarg!"
```
&emsp;&emsp;如果你设置一个断点在打印语句上，就可以在计算感兴趣的像素之前加入调试器。一些调试器拥有
条件断点功能，可以在不修改代码的情况下实现相同的功能。
&emsp;&emsp;在程序崩溃的情况下，一个传统的调试器可以用来精确定位崩溃的位置，然后你可以在程序中回溯，
添加断言然后重新编译，来找到程序错误。这些断言应该留在程序中，以便定位将来添加功能时的潜在错误，这意
味着又避开了传统的单步调试，因为这不会再添加有价值的断言到你的程序中。

### 数据可视化调试
&emsp;&emsp;通常很难去理解你的程序具体在做什么，因为在出错前，它计算了大量的中间值。这种情况类似于
一个测量大量数据的科学实验，有一个解决方案是:制作清晰地图表和图像帮助自己理解这些数据代表的意义。例如
:在光线追踪器中，你可以编写可视化的光线树，以便你看到一个像素对路径的贡献(you can see what paths 
contributed to a pixel),或者在一个图像重采样过程中，你可以绘制图标来显示除所有从输入中获取到的采
样点。编写可视化代码， 可以让你更好的理解程序的内部行为状态，也能够帮助你更好的优化你的代码。


